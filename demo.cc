#include "IF_CONSTEXPR.hh"
#include "IF_CONSTEXPR_ALL.hh"

#include <iostream>

int main() {
    int a=3;
    int b=4;
    int c=5;

    // First, demostrate the macro-free implementation. The structure
    // of these two statements look pretty strange, but it makes sense
    // as this is what is generated by the macros.

    std::cout
        <<  forward_as_tuple_for_if_constexpr(a,b)
            .if_constexpr(
                    std::integral_constant<bool, true>{}
                ,   [&](auto&&a,auto&&b){ return a*b;    }  // returns '12'
                ,   [&](auto&&a,auto&&b){ return a(b);   }  // branch not taken
               )
        <<'\n'; // prints '12'
    std::cout
        <<  forward_as_tuple_for_if_constexpr(a,b)
            .if_constexpr(
                    std::integral_constant<bool, false>{}
                ,   [&](auto&&a,auto&&b){ return a(b);   }  // branch not taken
                ,   [&](auto&&a,auto&&b){ return a+b;    }  // returns '7'
               )
        <<'\n'; // prints '7'

    // Next, the demonstrations of the IF_CONSTEXPR macro

    std:: cout <<    IF_CONSTEXPR    (       true,
           a*b                      // returns 12
    )(
           a+b                      // branch not taken
    )
    << '\n';                        // prints '12'
    std:: cout <<    IF_CONSTEXPR    ( a,    false,
           a(b)                     // branch not taken
    )(
           a+b                      // returns 7
    )
    << '\n';                        // prints '7'
    std:: cout <<    IF_CONSTEXPR    ( a,b,c,  true,
           a*b*c                    // returns 60
    )(
           a(b) + c + b(a)          // branch not taken
    )
    << '\n';                        // prints '60'


    std:: cout << '\n';

    std:: cout <<
    [&]() ->decltype(auto) {

        struct local_copy_of_args_t {
            decltype(a)  &  a;
            decltype(b)  &  b;
        };

        auto local_copy_of_args = local_copy_of_args_t  {   a,   b   };

        constexpr bool condition_variable = false;

        auto first_expression_lambda = [](auto && local_copy_of_args, auto && dummy) ->decltype(auto) {
            struct first_expression_t : local_copy_of_args_t, std::remove_reference_t<decltype(dummy)> {
                first_expression_t(local_copy_of_args_t&& l) : local_copy_of_args_t( std::move(l) ) {}
                decltype(auto)  go() {
                    return a+(b);
                }
            };
            return first_expression_t( std::move(local_copy_of_args) ) . go();
        };
        auto second_expression_lambda = [](auto && local_copy_of_args, auto && dummy) ->decltype(auto) {
            struct second_expression_t : local_copy_of_args_t, std::remove_reference_t<decltype(dummy)> {
                second_expression_t(local_copy_of_args_t&& l) : local_copy_of_args_t( std::move(l) ) {}
                decltype(auto)  go() {
                    return a*(b);
                }
            };
            return second_expression_t( std::move(local_copy_of_args) ) . go();
        };
        return
            return_the_first_arg_if_true
            (   std::integral_constant<bool, condition_variable>{}
            ,    first_expression_lambda
            ,   second_expression_lambda
            )
            ( std::move(local_copy_of_args), empty_t{} );
    }() << '\n';
}
